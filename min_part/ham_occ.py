from itertools import combinations
from typing import List, Tuple

from min_part.ham_decomp import make_lambda_matrix
from min_part.tensor import get_no_from_tensor
from min_part.typing import GFROFragment


def generate_occupied_spin_orb_permutations(total_spin_orbs: int) -> List[Tuple[int]]:
    possible_spin_orbs = list(range(total_spin_orbs))
    possible_permutations = []
    for i in possible_spin_orbs:
        possible_permutations += list(combinations(possible_spin_orbs, i))
    possible_permutations.append(tuple(possible_spin_orbs))
    return possible_permutations


def fr_fragment_occ(
    fragment: GFROFragment, num_spin_orbs: int
) -> List[Tuple[Tuple[int], float]]:
    """Given a fragment generated by GFRO, determine the energy of the fragment for all possible electron
    occupation configurations. Assumes `openfermion` spin orbital numbering, where even numbers are spin up, and
    odd numbers are spin down.

    Args:
        fragment: a fragment in the GFRO fragment form
        num_spin_orbs: number of all orbitals (the alpha and beta orbitals count as 2)

    Returns:
        energies of the fragment given a certain occupation of spin orbitals
    """
    gfro_operator = get_no_from_tensor(
        make_lambda_matrix(fragment.lambdas, num_spin_orbs)
    )
    occupation_permutations = generate_occupied_spin_orb_permutations(num_spin_orbs)


def lr_fragment_occ(
    fragment, num_spin_orbs: int, occupied_spin_orbs: List[int]
) -> List[float]:
    pass
