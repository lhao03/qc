from itertools import combinations
from typing import List, Tuple, Any

from numpy import ndarray, dtype

from min_part.ham_decomp import make_lambda_matrix
from min_part.typing import GFROFragment
import numpy as np


def generate_occupied_spin_orb_permutations(total_spin_orbs: int) -> List[Tuple[int]]:
    possible_spin_orbs = list(range(total_spin_orbs))
    possible_permutations = []
    for i in possible_spin_orbs:
        possible_permutations += list(combinations(possible_spin_orbs, i))
    possible_permutations.append(tuple(possible_spin_orbs))
    return possible_permutations


def gfro_fragment_occ(
    fragment: GFROFragment, num_spin_orbs: int
) -> Tuple[list[Tuple[int]], ndarray[Any, dtype[Any]]]:
    """Given a fragment generated by GFRO, determine the energy of the fragment for all possible electron
    occupation configurations. Assumes `openfermion` spin orbital numbering, where even numbers are spin up, and
    odd numbers are spin down.

    Args:
        fragment: a fragment in the GFRO fragment form
        num_spin_orbs: number of all orbitals (the alpha and beta orbitals count as 2)

    Returns:
        energies of the fragment given a certain occupation of spin orbitals
    """
    lambda_matrix = make_lambda_matrix(fragment.lambdas, num_spin_orbs)
    occupation_combinations = generate_occupied_spin_orb_permutations(num_spin_orbs)
    occ_energies = []
    for occ_comb in occupation_combinations:
        occ_energy = 0
        for l in occ_comb:
            for m in occ_comb:
                occ_energy += lambda_matrix[l][m]
        occ_energies.append(occ_energy)
    return occupation_combinations, np.array(occ_energies)


def lr_fragment_occ(
    fragment, num_spin_orbs: int, occupied_spin_orbs: List[int]
) -> List[float]:
    pass
